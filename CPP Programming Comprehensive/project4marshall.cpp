/*
* Laura Marshall
* Project Number: 4
* Due Date: 08/31/2010
* Compiler Used: Visual Studio 2008
* File Name: project4_marshalll.cpp
*
* Purpose:  This project uses Inheritance and Polymorphism.
* Classes Airplane and Balloon are derived from Airship such
* that Balloons and Airplanes can be used interchangably
* in a Linked List containing Type Airship*.  Linked List CLink is generic.
*
* The AirshipManager reads in data from a file to create
* Balloons and Airplanes and store them in a Linked List.
* A report is generated by iterating through this Linked List
* once to show only the Airplanes and a second time to show only the
* Balloons.
*
* Linked List uses Generic programming with templates.
* Added Exception handling to catch errors in data if user's file specified a
* string in a field requiring an int or double.
*/
#include <iomanip>
#include <iostream>
#include <fstream>
#include <string>
#include <limits>
#include <vector>
#include <sstream>
#include <cstring>
#include <cstdlib>

using namespace std;

/*
Class: CLink
Purpose:  Stores any generic Object of type T in a LinkList.
*/
template <typename T>
class CLink {
public:

	CLink() : m_pLink(0), m_pDataObject(0) {};
	CLink(T DataObj) : m_pLink(0), m_pDataObject(DataObj) {};
	~CLink() { delete m_pDataObject; };

	// Add a new node to the Linked List at the end
	CLink<T>* Append(CLink* pHeadNode, CLink* NewNode);

	// Delete the Links in the Link List
	void RemoveLinks(CLink *pHeadPtr);

	// List all Links of a specific type defined by T->GetType()
	void List(CLink* pHeadPtr, string type);

	CLink<T>* GetNext() { return m_pLink; };
	void SetNext(CLink<T>* pNext) { m_pLink = pNext; };

	// Getter and Setter for Data Object
	T GetDataObject() { return m_pDataObject; };
	void SetDataObject(T DataObj) { m_pDataObject = DataObj; };

private:
	T m_pDataObject;
	CLink<T> *m_pLink;
};

/********************************************************************
* FUNCTION: RemoveLinks *
* PURPOSE: deletes memory spaces that were being *
* used. *
* PARAMETERS: pHeadNode *
* LOCAL VARIABLES: pCurr, pDeleteThisNode *
***********************************************************************/
template <typename T>
void CLink<T>::RemoveLinks (CLink<T> *pHeadNode)
{
	CLink<T> *pCurr, *pDeleteThisNode;
	pCurr = pHeadNode;
	while ( pCurr != 0)
	{
		pDeleteThisNode = pCurr;
		pCurr = pCurr->m_pLink;
		delete pDeleteThisNode;
	}
}

/********************************************************************
* FUNCTION: List
* PURPOSE:  displays the records to the screen.
* PARAMETERS: pHeadNode - the head node
***********************************************************************/
template <typename T>
void CLink<T>::List(CLink<T>* pHeadNode, string type) {
	CLink<T>* pCurNode = pHeadNode;

	int i = 0;

	while(pCurNode != 0){

		if ( pCurNode->GetDataObject()->GetType() == type ) {
			pCurNode->GetDataObject()->Show();
		}
		pCurNode = pCurNode->GetNext();
		i++;
	}
}


/***********************************************************************
* FUNCTION: Append
* PURPOSE: Appends a new CLink to the end of the linked list.
* PARAMETERS: pHeadNode - head node of the linked list.
			  pNewNode - new node to add to the linked list.
* PRECONDITION: pNewNode's next is initialized to null and is a valid CLink.
***********************************************************************/
template <typename T>
CLink<T>* CLink<T>::Append(CLink<T>* pHeadNode, CLink<T>* pNewNode) {
	CLink<T>* pCurNode = pHeadNode;
	CLink<T>* pPreviousNode = 0;

	// The linked list is empty so add the NewNode to the head
	if (!pCurNode) {
		pHeadNode = pNewNode;
		pCurNode = pNewNode;
	} else {

		/* while the new node is less that the current node */
		while ( pCurNode != 0 ) {


			/* At the end of the linked list so add new node */
			if (!pCurNode->GetNext()) {
				pCurNode->SetNext(pNewNode);
				/* pNewNode next is initialized to null*/
				pCurNode = pNewNode;
			}

			pPreviousNode = pCurNode;
			pCurNode = pCurNode->GetNext();
		}

	}

	return pHeadNode;
}

/***********************************************************************
* CLASS: Airship
* PURPOSE: Base class defines an airship used to derive Balloon and Airplane
* Classes which are derived from this class must implemenent Show() and GetType()
* GetType is used to ask an Airship if it is a Balloon or an Airplane.
* Classes which are derived from this class will inherit GetName()
***********************************************************************/
class Airship { // base class
public:

	// Constructor
	Airship(string name, int maxPassengerCount, double maxCargoWeight);
	virtual ~Airship(){};
	string GetName() { return m_name; };

	// pure virtual functions, must be implemented by derived classes
	virtual void Show() = 0;
	virtual const string GetType() = 0;

private:
	string m_name;
	int m_maxPassengerCount;
	double m_maxCargoWeight;
	double m_AmountOfCargo;

};

// Constructor
Airship::Airship(string name, int maxPassengerCount, double maxCargoWeight)
: m_name(name), m_maxCargoWeight(maxCargoWeight), m_maxPassengerCount(maxPassengerCount)
{
}

/***********************************************************************
* CLASS: Airplane
* PURPOSE: Derived class from airship.
* An Airplane is an Airship that has a range and engine_type.
* GetData is done in the constructor which constructs the base class data.
***********************************************************************/
class Airplane : public Airship { // derived class
public:
	// [Jet = 0, Propeller = 1]
	enum eEngineType { JET, PROPELLER };

	// Constructor does the job of GetData to initialize the base class Airship
	Airplane(string airplaneName, int maxPassengerCount, double maxCargoWeight, double range, eEngineType engineType);
	~Airplane(){};
	const string GetEngineType();

	// Functions required by the Airship class
	void Show();
	const string GetType() { return "Airplane"; };  // replaces airshipType for convenience

protected:
	double m_range;
	eEngineType m_engineType;

};

/***********************************************************************
* FUNCTION: GetEngineType
* PURPOSE: Return a string used to display engine type.
***********************************************************************/
const string Airplane::GetEngineType() {
	if (m_engineType == JET) {
		return "Jet";
	} else
	if (m_engineType == PROPELLER) {
		return "Propeller";
	} else {
		return "Unknown";
	}
}

// Constructor does the job of GetData to populate the data for the class and the base class
Airplane::Airplane(string airplaneName, int maxPassengerCount, double maxCargoWeight, double range, eEngineType engineType)
				 : Airship(airplaneName, maxPassengerCount, maxCargoWeight), m_range(range), m_engineType(engineType)
{
}


/***********************************************************************
* CLASS: Show
* PURPOSE: Display this airplane's data.
***********************************************************************/
void Airplane::Show() {

	cout << setw(20) << setfill(' ') << GetName();
	cout << setw(20) << setfill(' ') << GetEngineType();
	cout << setw(20) << setfill(' ') << m_range << endl;
}

/***********************************************************************
* CLASS: Balloon
* PURPOSE: Derived class from airship.
* An Balloon is an Airship that has a m_maxAltitude and m_gasType.
* GetData is done in the constructor which constructs the base class data.
***********************************************************************/
class Balloon : public Airship { // derived class
public:
	//[Helium = 0, Hydrogen = 1]
	enum eGasType { HELIUM, HYDROGEN };
	// Constructor does the job of GetData to initialize the base class Airship
	Balloon(string balloonName, int maxPassengerCount, double maxCargoWeight, double maxAltitude, eGasType gasType);
	~Balloon(){};
	const string GetGasType();

	// functions required by the Airship base class:
	void Show();
	const string GetType() { return "Balloon"; }

private:
	double m_maxAltitude;
	eGasType m_gasType;
};

// Constructor does the job of GetData to populate the data for this class and the base class
Balloon::Balloon(string name, int maxPassengerCount,double maxCargoWeight, double maxAltitude, eGasType gasType)
				 : Airship(name, maxPassengerCount, maxCargoWeight),
				 m_maxAltitude(maxAltitude),
				 m_gasType(gasType)
{
}

/***********************************************************************
* FUNCTION: GetGasType
* PURPOSE: Return a string used to display gas type.
* RETURNS: Helium, Hydrogen or Unknown
***********************************************************************/
const string Balloon::GetGasType() {

	if (m_gasType == HELIUM) {
		return "Helium";
	} else
	if (m_gasType == HYDROGEN) {
		return "Hydrogen";
	} else {
		return "Unknown";
	}
}


/***********************************************************************
* FUNCTION: Show
* PURPOSE: Display this Balloon's data.
* Required to implement Show to be an Airship.
***********************************************************************/
void Balloon::Show() {

	cout << setw(20) << setfill(' ') << GetName();
	cout << setw(20) << setfill(' ') << GetGasType();
	cout << setw(20) << setfill(' ') << m_maxAltitude << endl;
}

/***********************************************************************
* CLASS: AirshipManager
* PURPOSE: Manages Airships by reading in data from a file
* and storing Airplanes and Balloons into the Linked List.
* Tracks the headLink of the Linked List.
***********************************************************************/
class AirshipManager{
public:
	AirshipManager() : m_AirshipsCLinkList(0), m_pHeadLink(0) {};
	~AirshipManager() { delete m_AirshipsCLinkList; };
	enum eAirshipType { AIRPLANE, BALLOON };

	bool GetAirshipsFromFile(char* filename);
	void Show();
	void CleanUp();

	// helper functions
	vector<string> Split (const string& text, const string& delimeter);
	int string_to_int(string str_to_convert);
	double string_to_double(string str_to_convert);
private:
	CLink<Airship*>* m_AirshipsCLinkList;
	CLink<Airship*>* m_pHeadLink;
};


/***********************************************************************
* FUNCTION: Show
* PURPOSE: Calls the Linked List's List method which iterates over
* Balloons and Airplanes as Airship* types to show polymorphism.
* Displays a List of Airplanes and a List of Balloons to the screen.
***********************************************************************/
void AirshipManager::Show() {

	cout << "Listing of all Airplanes\n" << endl;
	cout << setw(20) << setfill(' ') <<"Name";
	cout << setw(20) << setfill(' ') << "Engine Type";
	cout << setw(20) << setfill(' ') << "Maximum Range" << endl;
	cout << setw(60) << setfill('_') << "_" << endl;

	m_AirshipsCLinkList->List(m_pHeadLink, "Airplane");

	cout << endl;

	cout << "Listing of all Balloons\n" << endl;
	cout << setw(20) << setfill(' ') << "Name";
	cout << setw(20) << setfill(' ') << "Gas Type";
	cout << setw(20) << setfill(' ') << "Maximum Altitude" << endl;
	cout << setw(60) << setfill('_') << "_" << endl;

	m_AirshipsCLinkList->List(m_pHeadLink, "Balloon");

	cout << endl;
}

/***********************************************************************
* CLASS: NumberFormatException
* PURPOSE: used for exceptions in converting strings to int or double.
***********************************************************************/
class NumberFormatException
{
public:
	NumberFormatException(string thefield): message("ERROR: Cannot convert field to number: "), field(thefield) { };
	const char* what() const {return message;}
	const string show_field() { return field; };

private:
	const char* message;
	const string field;

};

/***********************************************************************
* FUNCTION: string_to_int
* PURPOSE: Converts a string to an int.
* RETURNS: the int or throws NumberFormatException
***********************************************************************/
int AirshipManager::string_to_int(string str_to_convert) {
	int returnValue;

	istringstream myStream(str_to_convert);

	if ( myStream >> returnValue )
		return returnValue;
	else
		throw NumberFormatException(str_to_convert);
}

/***********************************************************************
* FUNCTION: string_to_double
* PURPOSE: Converts a string to an double.
* RETURNS: the double or throws NumberFormatException
***********************************************************************/
double AirshipManager::string_to_double(string str_to_convert) {
	double returnValue;

	istringstream myStream(str_to_convert);

	if ( myStream >> returnValue )
		return returnValue;
	else
		throw NumberFormatException(str_to_convert);
}

/***********************************************************************
* FUNCTION: GetAirshipsFromFile
* PURPOSE: Reads a File and parses the data into Balloons and Airships.
* Adds Balloons and Airships to the Link List.
* RETURNS: false if there were any problems
***********************************************************************/
bool AirshipManager::GetAirshipsFromFile(char* filename) {

	std::ifstream infile(filename);

	if (!infile){
		cout << "File not opened: " << filename << cout;
		return false;
	}

	string line; // string to be read from the file
	while ( std::getline(infile, line) ) {

		if (!infile.good()){
		} else {

			/* split the line into words and then convert appropriate fields
			   to numbers */
			vector<string> words;

			words = Split(line, ",");

			// AirShipType {Airplane=0,Ballon=1}
			int AirShipType = 0;

			// NumberOfPassengers
			int maxPassengerCount = 0;

			//AmountOfCargo
			double maxCargoWeight = 0.0;

			// {Engine Type [Jet = 0, Propeller = 1] Gas Type [Helium = 0, Hydrogen = 1]}
			int engine_or_gas_type = 0;

			//Maximum Range/Altitude
			double range_altitude = 0.0;

			string name = words[1];

			// Catches NumberFormatException thrown by string_to_int
			// or string_to_double
			try {
				AirShipType = string_to_int(words[0]);
				maxPassengerCount = string_to_int(words[2]);
				maxCargoWeight = string_to_double(words[3]);
				engine_or_gas_type = string_to_int(words[4]);
				range_altitude = string_to_double(words[5]);
			}
			catch (NumberFormatException ex) {
				cout << "Warning, an error occurred while reading in the line:\n\"" << line << "\".\n"<< ex.what();
				cout << ex.show_field() << endl;
				cout << "This line will be skipped.\n" << endl;
				continue;  // don't die, skip this line
			}

			Airship* airship;

			if (AirShipType == AIRPLANE)
			{
				airship = new Airplane(name,
					maxPassengerCount,
					maxCargoWeight,
					range_altitude,
					Airplane::eEngineType(engine_or_gas_type)
					);
			}
			else if (AirShipType == BALLOON)
			{
				airship = new Balloon(name,
					maxPassengerCount,
					maxCargoWeight,
					range_altitude,
					Balloon::eGasType(engine_or_gas_type)
					);

			} else {
				cout << "Invalid Type, skipping " << line << "." << endl;
			}

			// create a new link of data type Airship*
			CLink<Airship*>* pNewLink = new CLink<Airship*>(airship);

			// add the new Link to the Linked List
			m_pHeadLink = m_AirshipsCLinkList->Append(m_pHeadLink, pNewLink);

			std::cin.clear();
		}

	}	 //while
	return true;
}

/***********************************************************************
* FUNCTION: Split
* PURPOSE: splits a string into words by the delimeter.
* RETURNS: vector of strings.
***********************************************************************/
vector<string> AirshipManager::Split (const string& text, const string& delimeter) {
	vector<string> words;
    size_t n     = text.length();
    size_t start = text.find_first_not_of(delimeter);

    while (start < n) {
        size_t stop = text.find_first_of(delimeter, start);
        if (stop > n) stop = n;
        words.push_back(text.substr (start, stop-start));
        start = text.find_first_not_of(delimeter, stop+1);
    }
	return words;
}

/***********************************************************************
* FUNCTION: CleanUp
* PURPOSE: calls RemoveLinks to clean up the memory for the Linked List.
* Call before exiting the program to prevent  memory leaks.
***********************************************************************/
void AirshipManager::CleanUp() {
	m_AirshipsCLinkList->RemoveLinks(m_pHeadLink);
}

int main(int argc, char *argv[]){

	AirshipManager* manager = new AirshipManager();

	if (argc == 2){
		bool bFileReadSuccess = false;
		bFileReadSuccess = manager->GetAirshipsFromFile(argv[1]);
		if (!bFileReadSuccess){
			std::cout << "Error reading file." << std::endl;
			return 1;
		}
	} else {
		std::cout << "Error: Invalid usage." << std::endl;
		std::cout << "Usage: " << argv[0] << " <filename>" << std::endl;
		return 1;
	}

	manager->Show();

	// Delete nodes of the Link List
	manager->CleanUp();

	delete manager;
	return 0;
}

/*
* Laura Marshall
* Project Number: 4
* Due Date: 08/31/2010
* Compiler Used: Visual Studio 2008
* File Name: project4_marshalll.cpp
*
* Purpose:  This project uses Inheritance and Polymorphism.
* Classes Airplane and Balloon are derived from Airship such
* that Balloons and Airplanes can be used interchangably
* in a Linked List containing Type Airship*.  Linked List CLink is generic.
*
* The AirshipManager reads in data from a file to create
* Balloons and Airplanes and store them in a Linked List.
* A report is generated by iterating through this Linked List
* once to show only the Airplanes and a second time to show only the
* Balloons.
*
* Linked List uses Generic programming with templates.
* Added Exception handling to catch errors in data if user's file specified a
* string in a field requiring an int or double.
*/
#include <iomanip>
#include <iostream>
#include <fstream>
#include <string>
#include <limits>
#include <vector>
#include <sstream>
#include <cstring>
#include <cstdlib>

using namespace std;

/*
Class: CLink
Purpose:  Stores any generic Object of type T in a LinkList.
*/
template <typename T>
class CLink {
public:

	CLink() : m_pLink(0), m_pDataObject(0) {};
	CLink(T DataObj) : m_pLink(0), m_pDataObject(DataObj) {};
	~CLink() { delete m_pDataObject; };

	// Add a new node to the Linked List at the end
	CLink<T>* Append(CLink* pHeadNode, CLink* NewNode);

	// Delete the Links in the Link List
	void RemoveLinks(CLink *pHeadPtr);

	// List all Links of a specific type defined by T->GetType()
	void List(CLink* pHeadPtr, string type);

	CLink<T>* GetNext() { return m_pLink; };
	void SetNext(CLink<T>* pNext) { m_pLink = pNext; };

	// Getter and Setter for Data Object
	T GetDataObject() { return m_pDataObject; };
	void SetDataObject(T DataObj) { m_pDataObject = DataObj; };

private:
	T m_pDataObject;
	CLink<T> *m_pLink;
};

/********************************************************************
* FUNCTION: RemoveLinks *
* PURPOSE: deletes memory spaces that were being *
* used. *
* PARAMETERS: pHeadNode *
* LOCAL VARIABLES: pCurr, pDeleteThisNode *
***********************************************************************/
template <typename T>
void CLink<T>::RemoveLinks (CLink<T> *pHeadNode)
{
	CLink<T> *pCurr, *pDeleteThisNode;
	pCurr = pHeadNode;
	while ( pCurr != 0)
	{
		pDeleteThisNode = pCurr;
		pCurr = pCurr->m_pLink;
		delete pDeleteThisNode;
	}
}

/********************************************************************
* FUNCTION: List
* PURPOSE:  displays the records to the screen.
* PARAMETERS: pHeadNode - the head node
***********************************************************************/
template <typename T>
void CLink<T>::List(CLink<T>* pHeadNode, string type) {
	CLink<T>* pCurNode = pHeadNode;

	int i = 0;

	while(pCurNode != 0){

		if ( pCurNode->GetDataObject()->GetType() == type ) {
			pCurNode->GetDataObject()->Show();
		}
		pCurNode = pCurNode->GetNext();
		i++;
	}
}


/***********************************************************************
* FUNCTION: Append
* PURPOSE: Appends a new CLink to the end of the linked list.
* PARAMETERS: pHeadNode - head node of the linked list.
			  pNewNode - new node to add to the linked list.
* PRECONDITION: pNewNode's next is initialized to null and is a valid CLink.
***********************************************************************/
template <typename T>
CLink<T>* CLink<T>::Append(CLink<T>* pHeadNode, CLink<T>* pNewNode) {
	CLink<T>* pCurNode = pHeadNode;
	CLink<T>* pPreviousNode = 0;

	// The linked list is empty so add the NewNode to the head
	if (!pCurNode) {
		pHeadNode = pNewNode;
		pCurNode = pNewNode;
	} else {

		/* while the new node is less that the current node */
		while ( pCurNode != 0 ) {


			/* At the end of the linked list so add new node */
			if (!pCurNode->GetNext()) {
				pCurNode->SetNext(pNewNode);
				/* pNewNode next is initialized to null*/
				pCurNode = pNewNode;
			}

			pPreviousNode = pCurNode;
			pCurNode = pCurNode->GetNext();
		}

	}

	return pHeadNode;
}

/***********************************************************************
* CLASS: Airship
* PURPOSE: Base class defines an airship used to derive Balloon and Airplane
* Classes which are derived from this class must implemenent Show() and GetType()
* GetType is used to ask an Airship if it is a Balloon or an Airplane.
* Classes which are derived from this class will inherit GetName()
***********************************************************************/
class Airship { // base class
public:

	// Constructor
	Airship(string name, int maxPassengerCount, double maxCargoWeight);
	virtual ~Airship(){};
	string GetName() { return m_name; };

	// pure virtual functions, must be implemented by derived classes
	virtual void Show() = 0;
	virtual const string GetType() = 0;

private:
	string m_name;
	int m_maxPassengerCount;
	double m_maxCargoWeight;
	double m_AmountOfCargo;

};

// Constructor
Airship::Airship(string name, int maxPassengerCount, double maxCargoWeight)
: m_name(name), m_maxCargoWeight(maxCargoWeight), m_maxPassengerCount(maxPassengerCount)
{
}

/***********************************************************************
* CLASS: Airplane
* PURPOSE: Derived class from airship.
* An Airplane is an Airship that has a range and engine_type.
* GetData is done in the constructor which constructs the base class data.
***********************************************************************/
class Airplane : public Airship { // derived class
public:
	// [Jet = 0, Propeller = 1]
	enum eEngineType { JET, PROPELLER };

	// Constructor does the job of GetData to initialize the base class Airship
	Airplane(string airplaneName, int maxPassengerCount, double maxCargoWeight, double range, eEngineType engineType);
	~Airplane(){};
	const string GetEngineType();

	// Functions required by the Airship class
	void Show();
	const string GetType() { return "Airplane"; };  // replaces airshipType for convenience

protected:
	double m_range;
	eEngineType m_engineType;

};

/***********************************************************************
* FUNCTION: GetEngineType
* PURPOSE: Return a string used to display engine type.
***********************************************************************/
const string Airplane::GetEngineType() {
	if (m_engineType == JET) {
		return "Jet";
	} else
	if (m_engineType == PROPELLER) {
		return "Propeller";
	} else {
		return "Unknown";
	}
}

// Constructor does the job of GetData to populate the data for the class and the base class
Airplane::Airplane(string airplaneName, int maxPassengerCount, double maxCargoWeight, double range, eEngineType engineType)
				 : Airship(airplaneName, maxPassengerCount, maxCargoWeight), m_range(range), m_engineType(engineType)
{
}


/***********************************************************************
* CLASS: Show
* PURPOSE: Display this airplane's data.
***********************************************************************/
void Airplane::Show() {

	cout << setw(20) << setfill(' ') << GetName();
	cout << setw(20) << setfill(' ') << GetEngineType();
	cout << setw(20) << setfill(' ') << m_range << endl;
}

/***********************************************************************
* CLASS: Balloon
* PURPOSE: Derived class from airship.
* An Balloon is an Airship that has a m_maxAltitude and m_gasType.
* GetData is done in the constructor which constructs the base class data.
***********************************************************************/
class Balloon : public Airship { // derived class
public:
	//[Helium = 0, Hydrogen = 1]
	enum eGasType { HELIUM, HYDROGEN };
	// Constructor does the job of GetData to initialize the base class Airship
	Balloon(string balloonName, int maxPassengerCount, double maxCargoWeight, double maxAltitude, eGasType gasType);
	~Balloon(){};
	const string GetGasType();

	// functions required by the Airship base class:
	void Show();
	const string GetType() { return "Balloon"; }

private:
	double m_maxAltitude;
	eGasType m_gasType;
};

// Constructor does the job of GetData to populate the data for this class and the base class
Balloon::Balloon(string name, int maxPassengerCount,double maxCargoWeight, double maxAltitude, eGasType gasType)
				 : Airship(name, maxPassengerCount, maxCargoWeight),
				 m_maxAltitude(maxAltitude),
				 m_gasType(gasType)
{
}

/***********************************************************************
* FUNCTION: GetGasType
* PURPOSE: Return a string used to display gas type.
* RETURNS: Helium, Hydrogen or Unknown
***********************************************************************/
const string Balloon::GetGasType() {

	if (m_gasType == HELIUM) {
		return "Helium";
	} else
	if (m_gasType == HYDROGEN) {
		return "Hydrogen";
	} else {
		return "Unknown";
	}
}


/***********************************************************************
* FUNCTION: Show
* PURPOSE: Display this Balloon's data.
* Required to implement Show to be an Airship.
***********************************************************************/
void Balloon::Show() {

	cout << setw(20) << setfill(' ') << GetName();
	cout << setw(20) << setfill(' ') << GetGasType();
	cout << setw(20) << setfill(' ') << m_maxAltitude << endl;
}

/***********************************************************************
* CLASS: AirshipManager
* PURPOSE: Manages Airships by reading in data from a file
* and storing Airplanes and Balloons into the Linked List.
* Tracks the headLink of the Linked List.
***********************************************************************/
class AirshipManager{
public:
	AirshipManager() : m_AirshipsCLinkList(0), m_pHeadLink(0) {};
	~AirshipManager() { delete m_AirshipsCLinkList; };
	enum eAirshipType { AIRPLANE, BALLOON };

	bool GetAirshipsFromFile(char* filename);
	void Show();
	void CleanUp();

	// helper functions
	vector<string> Split (const string& text, const string& delimeter);
	int string_to_int(string str_to_convert);
	double string_to_double(string str_to_convert);
private:
	CLink<Airship*>* m_AirshipsCLinkList;
	CLink<Airship*>* m_pHeadLink;
};


/***********************************************************************
* FUNCTION: Show
* PURPOSE: Calls the Linked List's List method which iterates over
* Balloons and Airplanes as Airship* types to show polymorphism.
* Displays a List of Airplanes and a List of Balloons to the screen.
***********************************************************************/
void AirshipManager::Show() {

	cout << "Listing of all Airplanes\n" << endl;
	cout << setw(20) << setfill(' ') <<"Name";
	cout << setw(20) << setfill(' ') << "Engine Type";
	cout << setw(20) << setfill(' ') << "Maximum Range" << endl;
	cout << setw(60) << setfill('_') << "_" << endl;

	m_AirshipsCLinkList->List(m_pHeadLink, "Airplane");

	cout << endl;

	cout << "Listing of all Balloons\n" << endl;
	cout << setw(20) << setfill(' ') << "Name";
	cout << setw(20) << setfill(' ') << "Gas Type";
	cout << setw(20) << setfill(' ') << "Maximum Altitude" << endl;
	cout << setw(60) << setfill('_') << "_" << endl;

	m_AirshipsCLinkList->List(m_pHeadLink, "Balloon");

	cout << endl;
}

/***********************************************************************
* CLASS: NumberFormatException
* PURPOSE: used for exceptions in converting strings to int or double.
***********************************************************************/
class NumberFormatException
{
public:
	NumberFormatException(string thefield): message("ERROR: Cannot convert field to number: "), field(thefield) { };
	const char* what() const {return message;}
	const string show_field() { return field; };

private:
	const char* message;
	const string field;

};

/***********************************************************************
* FUNCTION: string_to_int
* PURPOSE: Converts a string to an int.
* RETURNS: the int or throws NumberFormatException
***********************************************************************/
int AirshipManager::string_to_int(string str_to_convert) {
	int returnValue;

	istringstream myStream(str_to_convert);

	if ( myStream >> returnValue )
		return returnValue;
	else
		throw NumberFormatException(str_to_convert);
}

/***********************************************************************
* FUNCTION: string_to_double
* PURPOSE: Converts a string to an double.
* RETURNS: the double or throws NumberFormatException
***********************************************************************/
double AirshipManager::string_to_double(string str_to_convert) {
	double returnValue;

	istringstream myStream(str_to_convert);

	if ( myStream >> returnValue )
		return returnValue;
	else
		throw NumberFormatException(str_to_convert);
}

/***********************************************************************
* FUNCTION: GetAirshipsFromFile
* PURPOSE: Reads a File and parses the data into Balloons and Airships.
* Adds Balloons and Airships to the Link List.
* RETURNS: false if there were any problems
***********************************************************************/
bool AirshipManager::GetAirshipsFromFile(char* filename) {

	std::ifstream infile(filename);

	if (!infile){
		cout << "File not opened: " << filename << cout;
		return false;
	}

	string line; // string to be read from the file
	while ( std::getline(infile, line) ) {

		if (!infile.good()){
		} else {

			/* split the line into words and then convert appropriate fields
			   to numbers */
			vector<string> words;

			words = Split(line, ",");

			// AirShipType {Airplane=0,Ballon=1}
			int AirShipType = 0;

			// NumberOfPassengers
			int maxPassengerCount = 0;

			//AmountOfCargo
			double maxCargoWeight = 0.0;

			// {Engine Type [Jet = 0, Propeller = 1] Gas Type [Helium = 0, Hydrogen = 1]}
			int engine_or_gas_type = 0;

			//Maximum Range/Altitude
			double range_altitude = 0.0;

			string name = words[1];

			// Catches NumberFormatException thrown by string_to_int
			// or string_to_double
			try {
				AirShipType = string_to_int(words[0]);
				maxPassengerCount = string_to_int(words[2]);
				maxCargoWeight = string_to_double(words[3]);
				engine_or_gas_type = string_to_int(words[4]);
				range_altitude = string_to_double(words[5]);
			}
			catch (NumberFormatException ex) {
				cout << "Warning, an error occurred while reading in the line:\n\"" << line << "\".\n"<< ex.what();
				cout << ex.show_field() << endl;
				cout << "This line will be skipped.\n" << endl;
				continue;  // don't die, skip this line
			}

			Airship* airship;

			if (AirShipType == AIRPLANE)
			{
				airship = new Airplane(name,
					maxPassengerCount,
					maxCargoWeight,
					range_altitude,
					Airplane::eEngineType(engine_or_gas_type)
					);
			}
			else if (AirShipType == BALLOON)
			{
				airship = new Balloon(name,
					maxPassengerCount,
					maxCargoWeight,
					range_altitude,
					Balloon::eGasType(engine_or_gas_type)
					);

			} else {
				cout << "Invalid Type, skipping " << line << "." << endl;
			}

			// create a new link of data type Airship*
			CLink<Airship*>* pNewLink = new CLink<Airship*>(airship);

			// add the new Link to the Linked List
			m_pHeadLink = m_AirshipsCLinkList->Append(m_pHeadLink, pNewLink);

			std::cin.clear();
		}

	}	 //while
	return true;
}

/***********************************************************************
* FUNCTION: Split
* PURPOSE: splits a string into words by the delimeter.
* RETURNS: vector of strings.
***********************************************************************/
vector<string> AirshipManager::Split (const string& text, const string& delimeter) {
	vector<string> words;
    size_t n     = text.length();
    size_t start = text.find_first_not_of(delimeter);

    while (start < n) {
        size_t stop = text.find_first_of(delimeter, start);
        if (stop > n) stop = n;
        words.push_back(text.substr (start, stop-start));
        start = text.find_first_not_of(delimeter, stop+1);
    }
	return words;
}

/***********************************************************************
* FUNCTION: CleanUp
* PURPOSE: calls RemoveLinks to clean up the memory for the Linked List.
* Call before exiting the program to prevent  memory leaks.
***********************************************************************/
void AirshipManager::CleanUp() {
	m_AirshipsCLinkList->RemoveLinks(m_pHeadLink);
}

int main(int argc, char *argv[]){

	AirshipManager* manager = new AirshipManager();

	if (argc == 2){
		bool bFileReadSuccess = false;
		bFileReadSuccess = manager->GetAirshipsFromFile(argv[1]);
		if (!bFileReadSuccess){
			std::cout << "Error reading file." << std::endl;
			return 1;
		}
	} else {
		std::cout << "Error: Invalid usage." << std::endl;
		std::cout << "Usage: " << argv[0] << " <filename>" << std::endl;
		return 1;
	}

	manager->Show();

	// Delete nodes of the Link List
	manager->CleanUp();

	delete manager;
	return 0;
}

